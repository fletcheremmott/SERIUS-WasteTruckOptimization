<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VRP Optimization Frontend</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter (for a modern look) -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Ensure canvas is responsive */
        canvas {
            max-width: 100%;
            height: auto;
            display: block; /* Remove extra space below canvas */
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- React and ReactDOM CDNs -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX transformation in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        // Confirm JavaScript execution
        console.log("Babel script is running.");

        // --- VRP Instance Data (Parameters - mirroring Python defaults) ---
        const DEFAULT_NUM_BINS = 48;
        const DEFAULT_GRID_RANGE = 15; // 15x15 km grid
        const DEFAULT_BIN_VOLUME_MIN = 360; // kg
        const DEFAULT_BIN_VOLUME_MAX = 660; // kg
        const DEFAULT_BIN_SERVICE_TIME = 0.1; // hours

        const DEFAULT_TRUCK_CAPACITY = 10000; // kg
        const DEFAULT_TRUCK_SPEED = 40; // units/hour (remains for time calculation, though time cost is zeroed)

        const DEFAULT_START_DEPOT_LOCATION = { x: 0, y: 0 };
        const DEFAULT_END_DEPOT_LOCATION = { x: 0, y: 0 }; // Assuming trucks return to the same depot

        const DEFAULT_INCINERATOR_LOCATION = { x: 30, y: 30 };
        const DEFAULT_INCINERATOR_UNLOAD_TIME = 0.5; // hours
        const DEFAULT_INCINERATOR_ID = 'INC';
        const DEFAULT_DEPOT_ID = 'DEPOT';

        // --- Cost Parameters (prices in SGD) ---
        const COST_PER_KM = 3.2382;
        const GATE_FEE = 80;
        const COST_PER_ADDITIONAL_TRUCK = 200;

        // --- GA Parameters (for frontend execution) ---
        const GA_SOL_PER_POP = 100;
        const GA_NUM_PARENTS_MATING = 32;
        const GA_NUM_GENERATIONS = 100; // Can be increased, but might be very slow in browser
        const GA_MUTATION_RATE = 0.25;
        const GA_NUM_ELITE = 5;

        // Fitness weights now primarily for penalties, as monetary costs are explicit
        const FITNESS_WEIGHTS_SIMPLIFIED = {
            'unvisited': 1000000,            // High penalty for not visiting all bins
            'capacity_violation': 50000,     // High penalty for exceeding truck capacity
            'invalid_bin': 200000            // High penalty for invalid bin references
        };

        // --- Utility Functions (JavaScript equivalents of Python functions) ---
        const calculateDistance = (loc1, loc2) => {
            return Math.sqrt(Math.pow(loc1.x - loc2.x, 2) + Math.pow(loc1.y - loc2.y, 2));
        };

        const getCanvasCoordinates = (loc, canvasWidth, canvasHeight, gridRange, incineratorLoc) => {
            const maxX = Math.max(gridRange, incineratorLoc.x);
            const maxY = Math.max(gridRange, incineratorLoc.y);
            const effectiveGridRangeX = maxX + 5;
            const effectiveGridRangeY = maxY + 5;

            const scaleX = canvasWidth / effectiveGridRangeX;
            const scaleY = canvasHeight / effectiveGridRangeY;

            return {
                x: loc.x * scaleX,
                y: canvasHeight - (loc.y * scaleY)
            };
        };

        // --- GA Core Functions (Ported from WorkingAlgorithm.py) ---

        // Helper for argsort (mimics numpy.argsort)
        const argsort = (array) => {
            const arrayObject = array.map((value, index) => ({ value, index }));
            arrayObject.sort((a, b) => a.value - b.value);
            return arrayObject.map(data => data.index);
        };

        // Helper for random.sample (mimics Python's random.sample)
        const randomSample = (array, count) => {
            const shuffled = [...array].sort(() => 0.5 - Math.random());
            return shuffled.slice(0, count);
        };

        // Helper for random.shuffle (mimics Python's random.shuffle)
        const shuffleArray = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        };

        // Prim's algorithm for MST (simplified - not using a min-heap directly, but sorting)
        // For a true min-heap, a more complex implementation would be needed.
        const calculateMstForBinsAndDepot = (binsData, depotLoc) => {
            const nodes = { 'depot': depotLoc };
            for (const binId in binsData) {
                nodes[binId] = binsData[binId].loc;
            }

            if (Object.keys(nodes).length === 0) {
                return 0;
            }

            let minCost = 0;
            const nodeIds = Object.keys(nodes);
            const startNodeId = nodeIds[0];
            
            const visited = new Set();
            const distances = {}; // Stores min distance from visited set to each unvisited node
            
            for (const nodeId of nodeIds) {
                distances[nodeId] = Infinity;
            }
            distances[startNodeId] = 0;

            while (visited.size < nodeIds.length) {
                let currentNodeId = null;
                let minDistance = Infinity;

                for (const nodeId of nodeIds) {
                    if (!visited.has(nodeId) && distances[nodeId] < minDistance) {
                        minDistance = distances[nodeId];
                        currentNodeId = nodeId;
                    }
                }

                if (currentNodeId === null) { // Graph is disconnected
                    return Infinity;
                }

                visited.add(currentNodeId);
                minCost += distances[currentNodeId];

                const currentCoords = nodes[currentNodeId];

                for (const neighborId of nodeIds) {
                    if (!visited.has(neighborId)) {
                        const distance = calculateDistance(currentCoords, nodes[neighborId]);
                        if (distance < distances[neighborId]) {
                            distances[neighborId] = distance;
                        }
                    }
                }
            }
            return minCost;
        };

        const calculateClosestBinDistanceTheoretical = (binsData, incineratorLoc) => {
            let theoreticalClosest = Infinity;
            if (Object.keys(binsData).length === 0) {
                return 0;
            }

            for (const binId in binsData) {
                const dist = calculateDistance(binsData[binId].loc, incineratorLoc);
                if (dist < theoreticalClosest) {
                    theoreticalClosest = dist;
                }
            }
            return theoreticalClosest;
        };

        const calculateIncineratorRoundTripCost = (binsData, incineratorLoc, depotLoc, minTrips, costPerKm) => {
            if (minTrips === 0 || Object.keys(binsData).length === 0) {
                return 0;
            }

            const incToDepot = calculateDistance(incineratorLoc, depotLoc);
            const closestBinToIncDist = calculateClosestBinDistanceTheoretical(binsData, incineratorLoc);
            
            let totalIncineratorTravelDistance = 0;
            if (minTrips > 0) {
                totalIncineratorTravelDistance += closestBinToIncDist + incToDepot;
                totalIncineratorTravelDistance += (minTrips - 1) * (2 * closestBinToIncDist);
            }
            
            return totalIncineratorTravelDistance * costPerKm;
        };


        const calculateFitnessVrpSimplified = (chromosome, binsData, truckCapacity, incineratorLocationCoords,
                                               startDepotLocation, endDepotLocation, truckSpeed,
                                               incineratorUnloadTime, costPerKm, gateFee, costPerAdditionalTruck, weights) => {
            let totalDistance = 0;
            let totalTime = 0;
            let totalIncineratorTrips = 0;
            let trucksUsedInChromosome = 0;

            const allBinsInProblemLocal = new Set(Object.keys(binsData));
            const visitedBinsInChromosome = new Set();

            let capacityViolationPenalty = 0;
            let unvisitedBinPenalty = 0;
            let invalidBinPenaltyVal = 0;

            for (let truckIdx = 0; truckIdx < chromosome.length; truckIdx++) {
                const truckRoute = chromosome[truckIdx];
                let currentLoad = 0;
                let currentTruckDistance = 0;
                let currentTruckTime = 0;
                let lastLocation = startDepotLocation;
                let hasCollectedAnyBinsThisTruck = false;

                const hasAnyBinsInRoute = truckRoute.some(stopId => binsData.hasOwnProperty(stopId));
                if (hasAnyBinsInRoute) {
                    trucksUsedInChromosome += 1;
                }
                
                if (!truckRoute || (truckRoute.length === 2 && truckRoute[0] === DEFAULT_DEPOT_ID && truckRoute[1] === DEFAULT_DEPOT_ID)) {
                    continue;
                }

                const processedRoute = [...truckRoute];
                if (!processedRoute || processedRoute[0] !== DEFAULT_DEPOT_ID) {
                    processedRoute.unshift(DEFAULT_DEPOT_ID); // Add to beginning
                }

                for (let i = 0; i < processedRoute.length; i++) {
                    const stopId = processedRoute[i];
                    let currentLocation = null;

                    if (stopId === DEFAULT_DEPOT_ID) {
                        currentLocation = (i === 0) ? startDepotLocation : endDepotLocation;
                    } else if (stopId === DEFAULT_INCINERATOR_ID) {
                        currentLocation = incineratorLocationCoords;
                        totalIncineratorTrips += 1;
                        currentTruckTime += incineratorUnloadTime;
                        currentLoad = 0;
                    } else {
                        if (!binsData.hasOwnProperty(stopId)) {
                            invalidBinPenaltyVal += weights['invalid_bin'] || 200000;
                            continue;
                        }
                        const binInfo = binsData[stopId];
                        currentLocation = binInfo.loc;
                        visitedBinsInChromosome.add(stopId);
                        hasCollectedAnyBinsThisTruck = true;
                        if (currentLoad + binInfo.volume > truckCapacity) {
                            capacityViolationPenalty += (weights['capacity_violation'] || 50000) *
                                                        (currentLoad + binInfo.volume - truckCapacity);
                        }
                        currentLoad += binInfo.volume;
                        currentTruckTime += binInfo.service_time;
                    }

                    if (currentLocation !== null) {
                        const dist = calculateDistance(lastLocation, currentLocation);
                        currentTruckDistance += dist;
                        currentTruckTime += dist / truckSpeed; // Assuming truckSpeed > 0
                        lastLocation = currentLocation;
                    }
                }

                if (hasCollectedAnyBinsThisTruck && currentLoad > 0) {
                    const distToInc = calculateDistance(lastLocation, incineratorLocationCoords);
                    currentTruckDistance += distToInc;
                    currentTruckTime += (distToInc / truckSpeed);
                    currentTruckTime += incineratorUnloadTime;
                    totalIncineratorTrips += 1;
                    const distIncToDepot = calculateDistance(incineratorLocationCoords, endDepotLocation);
                    currentTruckDistance += distIncToDepot;
                    currentTruckTime += (distIncToDepot / truckSpeed);
                } else {
                    if (lastLocation !== endDepotLocation) {
                        const distToFinalDepot = calculateDistance(lastLocation, endDepotLocation);
                        currentTruckDistance += distToFinalDepot;
                        currentTruckTime += (distToFinalDepot / truckSpeed);
                    }
                }

                totalDistance += currentTruckDistance;
                totalTime += currentTruckTime;
            }

            const unvisitedBins = new Set([...allBinsInProblemLocal].filter(x => !visitedBinsInChromosome.has(x)));
            if (unvisitedBins.size > 0) {
                unvisitedBinPenalty = unvisitedBins.size * (weights['unvisited'] || 1000000);
            }

            const drivingCost = totalDistance * costPerKm;
            const gateFeesCost = totalIncineratorTrips * gateFee;
            const additionalTruckCost = Math.max(0, trucksUsedInChromosome - 1) * costPerAdditionalTruck;

            const fitness = (drivingCost +
                           gateFeesCost +
                           additionalTruckCost +
                           unvisitedBinPenalty +
                           capacityViolationPenalty +
                           invalidBinPenaltyVal);

            return fitness;
        };

        const createInitialVrpPopulation = (solPerPop, binsDataKeys, numTrucks, depotId, incineratorId, truckCapacity, binsData) => {
            const population = [];
            const allBinIds = [...binsDataKeys];

            for (let _ = 0; _ < solPerPop; _++) {
                const chromosome = [];
                const shuffledBins = [...allBinIds];
                shuffleArray(shuffledBins);
                
                const binsPerTruckBase = Math.floor(shuffledBins.length / numTrucks);
                const remainderBins = shuffledBins.length % numTrucks;
                
                let binIdxStart = 0;
                for (let i = 0; i < numTrucks; i++) {
                    const route = [depotId];
                    let currentCapSim = 0;
                    
                    let numBinsForThisTruck = binsPerTruckBase;
                    if (i < remainderBins) {
                        numBinsForThisTruck += 1;
                    }

                    const binsForThisRoute = shuffledBins.slice(binIdxStart, binIdxStart + numBinsForThisTruck);
                    binIdxStart += numBinsForThisTruck;

                    for (const binId of binsForThisRoute) {
                        if (binsData.hasOwnProperty(binId)) {
                            const binVolume = binsData[binId].volume;
                            if (currentCapSim + binVolume > truckCapacity && currentCapSim > 0) {
                                route.push(incineratorId);
                                currentCapSim = 0;
                            }
                            route.push(binId);
                            currentCapSim += binVolume;
                        }
                    }
                    
                    if (currentCapSim > 0 && route.some(s => binsData.hasOwnProperty(s))) {
                         if (route[route.length - 1] !== incineratorId) {
                             route.push(incineratorId);
                         }
                    }
                    
                    if (route[route.length - 1] !== depotId) {
                        route.push(depotId);
                    }
                    chromosome.push(route);
                }
                population.push(chromosome);
            }
            return population;
        };

        const calculateFitnessForPopulation = (population, binsData, truckCapacity, incineratorLoc,
                                             startDepotLoc, endDepotLoc, speed, unloadTime,
                                             costPerKm, gateFee, costPerAdditionalTruck, fitnessWeights) => {
            const fitnessScores = [];
            for (const chromo of population) {
                fitnessScores.push(calculateFitnessVrpSimplified(
                    chromo, binsData, truckCapacity, incineratorLoc,
                    startDepotLoc, endDepotLoc, speed,
                    unloadTime, costPerKm, gateFee, costPerAdditionalTruck, fitnessWeights
                ));
            }
            return fitnessScores; // Return as plain array, not numpy array
        };

        const selectMatingPoolVrp = (population, fitness, numParents) => {
            const parents = [];
            const sortedIndices = argsort(fitness); // Use custom argsort
            for (let i = 0; i < numParents; i++) {
                parents.push(population[sortedIndices[i]]);
            }
            return parents;
        };

        const crossoverVrp = (parents, offspringSizeTuple, binsDataKeys, depotId, incineratorId) => {
            const offspring = [];
            const numOffspringNeeded = offspringSizeTuple[0];
            if (parents.length === 0) return [];

            for (let k = 0; k < numOffspringNeeded; k++) {
                const idx1 = Math.floor(Math.random() * parents.length);
                const idx2 = Math.floor(Math.random() * parents.length);
                const parent1 = parents[idx1];
                const parent2 = parents[idx2];
                
                const numRoutes = parent1.length || parent2.length;
                if (numRoutes === 0) {
                    offspring.push([[depotId, depotId]]);
                    continue;
                }
                
                const childRoutesRaw = Array.from({ length: numRoutes }, () => []);
                
                const crossoverPointRouteIdx = Math.floor(Math.random() * numRoutes);
                
                for (let r_idx = 0; r_idx < numRoutes; r_idx++) {
                    if (r_idx <= crossoverPointRouteIdx) {
                        childRoutesRaw[r_idx] = (r_idx < parent1.length) ? [...parent1[r_idx]] : [depotId, depotId];
                    } else {
                        childRoutesRaw[r_idx] = (r_idx < parent2.length) ? [...parent2[r_idx]] : [depotId, depotId];
                    }
                }

                const child = [];
                for (const route of childRoutesRaw) {
                    if (!route || route[0] !== depotId) {
                        route.unshift(depotId);
                    }
                    if (route[route.length - 1] !== depotId) {
                        route.push(depotId);
                    }
                    
                    const cleanedRoute = [route[0]];
                    for (let j = 1; j < route.length; j++) {
                        if ((route[j] === depotId && cleanedRoute[cleanedRoute.length - 1] === depotId) ||
                           (route[j] === incineratorId && cleanedRoute[cleanedRoute.length - 1] === incineratorId)) {
                            continue;
                        }
                        cleanedRoute.push(route[j]);
                    }
                    child.push(cleanedRoute);
                }
                offspring.push(child);
            }
            return offspring;
        };

        const mutationVrp = (offspringCrossover, mutationRate, binsDataKeys, depotId, incineratorId) => {
            const mutatedOffspring = [];
            const allBinsSet = new Set(binsDataKeys);
            for (const chromosome of offspringCrossover) {
                const mutatedChromosome = chromosome.map(route => [...route]);
                
                // Mutation 1: Swap two bins within a random route
                if (Math.random() < mutationRate) {
                    if (mutatedChromosome.length === 0) continue;
                    const truckIdxToMutate = Math.floor(Math.random() * mutatedChromosome.length);
                    const routeToMutate = mutatedChromosome[truckIdxToMutate];
                    
                    const binIndicesInRoute = routeToMutate.map((stop, i) => (stop !== depotId && stop !== incineratorId) ? i : -1).filter(i => i !== -1);
                    if (binIndicesInRoute.length >= 2) {
                        const [idx1Map, idx2Map] = randomSample(binIndicesInRoute, 2);
                        [routeToMutate[idx1Map], routeToMutate[idx2Map]] = [routeToMutate[idx2Map], routeToMutate[idx1Map]];
                    }
                }

                // Mutation 2: Move a bin from one route to another (or within the same route)
                if (Math.random() < mutationRate) {
                    if (mutatedChromosome.length === 0) continue;
                    
                    const candidateBinsToMove = [];
                    mutatedChromosome.forEach((route, r_idx) => {
                        route.forEach((stop, s_idx) => {
                            if (allBinsSet.has(stop)) {
                                candidateBinsToMove.push({ r_idx, s_idx, stop });
                            }
                        });
                    });
                    
                    if (candidateBinsToMove.length > 0) {
                        const { r_idx: sourceRouteIdx, s_idx: sourceStopIdx, stop: binToMove } = randomSample(candidateBinsToMove, 1)[0];
                        
                        mutatedChromosome[sourceRouteIdx].splice(sourceStopIdx, 1);
                        
                        const targetTruckIdx = Math.floor(Math.random() * mutatedChromosome.length);
                        const targetRoute = mutatedChromosome[targetTruckIdx];
                        
                        const insertPos = Math.floor(Math.random() * (Math.max(2, targetRoute.length - 1) - 1)) + 1; // At least 1, max len-2
                        targetRoute.splice(insertPos, 0, binToMove);
                        
                        // Basic cleanup for target route after insertion
                        if (!targetRoute || targetRoute[0] !== depotId) {
                            targetRoute.unshift(depotId);
                        }
                        if (targetRoute[targetRoute.length - 1] !== depotId) {
                            targetRoute.push(depotId);
                        }
                        
                        const cleanedTargetRoute = [targetRoute[0]];
                        for (let j = 1; j < targetRoute.length; j++) {
                            if ((targetRoute[j] === depotId && cleanedTargetRoute[cleanedTargetRoute.length - 1] === depotId) ||
                               (targetRoute[j] === incineratorId && cleanedTargetRoute[cleanedTargetRoute.length - 1] === incineratorId)) {
                                continue;
                            }
                            cleanedTargetRoute.push(targetRoute[j]);
                        }
                        mutatedChromosome[targetTruckIdx] = cleanedTargetRoute;
                    }
                }

                // Mutation 3: Add/Remove an incinerator trip (simple heuristic)
                if (Math.random() < mutationRate) {
                    if (mutatedChromosome.length === 0) continue;
                    const truckIdx = Math.floor(Math.random() * mutatedChromosome.length);
                    const route = mutatedChromosome[truckIdx];
                    
                    if (Math.random() < 0.5 && route.length > 2) { // Try to add
                        const insertPos = Math.floor(Math.random() * (route.length - 2)) + 1; // Between depot and end depot
                        if (route[insertPos] !== incineratorId && route[insertPos - 1] !== incineratorId) {
                            route.splice(insertPos, 0, incineratorId);
                        }
                    } else { // Try to remove
                        const incIndices = route.map((stop, i) => (stop === incineratorId && i !== 0 && i !== route.length - 1) ? i : -1).filter(i => i !== -1);
                        if (incIndices.length > 0) {
                            route.splice(randomSample(incIndices, 1)[0], 1);
                        }
                    }
                }
                mutatedOffspring.push(mutatedChromosome);
            }
            return mutatedOffspring;
        };

        // --- React App Component ---
        const App = () => {
            // Access React hooks directly from the global React object
            const canvasRef = React.useRef(null);
            const [binsData, setBinsData] = React.useState({});
            const [depotLocation, setDepotLocation] = React.useState(DEFAULT_START_DEPOT_LOCATION);
            const [incineratorLocation, setIncineratorLocation] = React.useState(DEFAULT_INCINERATOR_LOCATION);
            const [routeResult, setRouteResult] = React.useState(null); // Stores { route, totalDistance, totalIncineratorTrips, totalCost }
            const [totalTrash, setTotalTrash] = React.useState(0);
            const [isLoading, setIsLoading] = React.useState(false); // New loading state
            const [error, setError] = React.useState(null); // New error state

            const generatePoints = React.useCallback(() => {
                const newBinsData = {};
                let currentTotalTrash = 0;
                for (let i = 0; i < DEFAULT_NUM_BINS; i++) {
                    const binId = `bin${i + 1}`;
                    const locX = Math.random() * DEFAULT_GRID_RANGE;
                    const locY = Math.random() * DEFAULT_GRID_RANGE;
                    const volume = Math.random() * (DEFAULT_BIN_VOLUME_MAX - DEFAULT_BIN_VOLUME_MIN) + DEFAULT_BIN_VOLUME_MIN;
                    newBinsData[binId] = { loc: { x: locX, y: locY }, volume: volume, service_time: DEFAULT_BIN_SERVICE_TIME };
                    currentTotalTrash += volume;
                }
                setBinsData(newBinsData);
                setDepotLocation(DEFAULT_START_DEPOT_LOCATION);
                setIncineratorLocation(DEFAULT_INCINERATOR_LOCATION);
                setTotalTrash(currentTotalTrash);
                setRouteResult(null); // Clear previous route when new points are generated
                setError(null); // Clear any previous errors
            }, []);

            const drawCanvas = React.useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;

                ctx.clearRect(0, 0, canvasWidth, canvasHeight); // Clear canvas

                // Draw grid lines
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 0.5;
                const maxX = Math.max(DEFAULT_GRID_RANGE, DEFAULT_INCINERATOR_LOCATION.x);
                const maxY = Math.max(DEFAULT_GRID_RANGE, DEFAULT_INCINERATOR_LOCATION.y);
                const effectiveGridRangeX = maxX + 5;
                const effectiveGridRangeY = maxY + 5;
                const scaleX = canvasWidth / effectiveGridRangeX;
                const scaleY = canvasHeight / effectiveGridRangeY;

                for (let i = 0; i <= effectiveGridRangeX; i += 5) { // Every 5km
                    ctx.beginPath();
                    ctx.moveTo(getCanvasCoordinates({ x: i, y: 0 }, canvasWidth, canvasHeight, DEFAULT_GRID_RANGE, incineratorLocation).x, 0);
                    ctx.lineTo(getCanvasCoordinates({ x: i, y: 0 }, canvasWidth, canvasHeight, DEFAULT_GRID_RANGE, incineratorLocation).x, canvasHeight);
                    ctx.stroke();
                }
                for (let i = 0; i <= effectiveGridRangeY; i += 5) { // Every 5km
                    ctx.beginPath();
                    ctx.moveTo(0, getCanvasCoordinates({ x: 0, y: i }, canvasWidth, canvasHeight, DEFAULT_GRID_RANGE, incineratorLocation).y);
                    ctx.lineTo(canvasWidth, getCanvasCoordinates({ x: 0, y: i }, canvasWidth, canvasHeight, DEFAULT_GRID_RANGE, incineratorLocation).y);
                    ctx.stroke();
                }

                // Draw Depot
                ctx.fillStyle = 'black';
                const depotCanvasLoc = getCanvasCoordinates(depotLocation, canvasWidth, canvasHeight, DEFAULT_GRID_RANGE, incineratorLocation);
                ctx.beginPath();
                ctx.arc(depotCanvasLoc.x, depotCanvasLoc.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillText("Depot", depotCanvasLoc.x + 10, depotCanvasLoc.y + 5);

                // Draw Incinerator
                ctx.fillStyle = 'purple';
                const incCanvasLoc = getCanvasCoordinates(incineratorLocation, canvasWidth, canvasHeight, DEFAULT_GRID_RANGE, incineratorLocation);
                ctx.beginPath();
                ctx.moveTo(incCanvasLoc.x, incCanvasLoc.y - 8);
                ctx.lineTo(incCanvasLoc.x - 8, incCanvasLoc.y + 8);
                ctx.lineTo(incCanvasLoc.x + 8, incCanvasLoc.y + 8);
                ctx.closePath();
                ctx.fill();
                ctx.fillText("INC", incCanvasLoc.x + 10, incCanvasLoc.y + 5);

                // Draw Bins
                ctx.fillStyle = 'blue';
                for (const binId in binsData) {
                    const binLoc = binsData[binId].loc;
                    const canvasLoc = getCanvasCoordinates(binLoc, canvasWidth, canvasHeight, DEFAULT_GRID_RANGE, incineratorLocation);
                    ctx.beginPath();
                    ctx.arc(canvasLoc.x, canvasLoc.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillText(binId, canvasLoc.x + 8, canvasLoc.y + 3);
                }

                // Draw Route if available
                if (routeResult && routeResult.route && routeResult.route.length > 1) {
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 2;
                    ctx.beginPath();

                    let prevCanvasLoc = null;

                    for (let i = 0; i < routeResult.route.length; i++) {
                        const stopId = routeResult.route[i];
                        let stopLoc;

                        if (stopId === DEFAULT_DEPOT_ID) {
                            stopLoc = depotLocation;
                        } else if (stopId === DEFAULT_INCINERATOR_ID) {
                            stopLoc = incineratorLocation;
                        } else {
                            stopLoc = binsData[stopId]?.loc;
                        }

                        if (stopLoc) {
                            const currentCanvasLoc = getCanvasCoordinates(stopLoc, canvasWidth, canvasHeight, DEFAULT_GRID_RANGE, incineratorLocation);
                            if (i === 0) {
                                ctx.moveTo(currentCanvasLoc.x, currentCanvasLoc.y);
                            } else {
                                ctx.lineTo(currentCanvasLoc.x, currentCanvasLoc.y);
                                // Draw arrow
                                const headlen = 10; // length of head in pixels
                                const dx = currentCanvasLoc.x - prevCanvasLoc.x;
                                const dy = currentCanvasLoc.y - prevCanvasLoc.y;
                                const angle = Math.atan2(dy, dx);
                                ctx.lineTo(currentCanvasLoc.x - headlen * Math.cos(angle - Math.PI / 6), currentCanvasLoc.y - headlen * Math.sin(angle - Math.PI / 6));
                                ctx.moveTo(currentCanvasLoc.x, currentCanvasLoc.y);
                                ctx.lineTo(currentCanvasLoc.x - headlen * Math.cos(angle + Math.PI / 6), currentCanvasLoc.y - headlen * Math.sin(angle + Math.PI / 6));
                                ctx.moveTo(currentCanvasLoc.x, currentCanvasLoc.y); // Move back to end point for next line segment
                            }
                            prevCanvasLoc = currentCanvasLoc;
                        }
                    }
                    ctx.stroke();
                }
            }, [binsData, depotLocation, incineratorLocation, routeResult]);

            // Initial point generation on component mount
            React.useEffect(() => {
                generatePoints();
            }, [generatePoints]);

            // Redraw canvas whenever relevant data changes
            React.useEffect(() => {
                drawCanvas();
            }, [drawCanvas, binsData, depotLocation, incineratorLocation, routeResult]);

            const handleRunGaOptimization = () => {
                setIsLoading(true);
                setError(null);
                setRouteResult(null); // Clear previous route

                // Use a setTimeout to allow UI to update with loading state before heavy computation
                setTimeout(() => {
                    try {
                        const currentBinsData = binsData; // Use the currently generated bins
                        const binIdsList = Object.keys(currentBinsData);
                        const allBinsInProblem = new Set(binIdsList);

                        // GA parameters for this run
                        const numTrucksForGa = 1; // Fixed to 1 as per requirement
                        const numParentsMating = GA_NUM_PARENTS_MATING;
                        const numGenerations = GA_NUM_GENERATIONS;
                        const solPerPop = GA_SOL_PER_POP;
                        const mutationRate = GA_MUTATION_RATE;
                        const numElite = GA_NUM_ELITE;

                        let newPopulation = createInitialVrpPopulation(solPerPop, binIdsList, numTrucksForGa, DEFAULT_DEPOT_ID, DEFAULT_INCINERATOR_ID, DEFAULT_TRUCK_CAPACITY, currentBinsData);

                        let overallBestFitness = Infinity;
                        let bestRouteOverall = [];

                        for (let generation = 0; generation < numGenerations; generation++) {
                            const fitnessScores = calculateFitnessForPopulation(
                                newPopulation, currentBinsData, DEFAULT_TRUCK_CAPACITY,
                                incineratorLocation, depotLocation,
                                DEFAULT_END_DEPOT_LOCATION, DEFAULT_TRUCK_SPEED,
                                COST_PER_KM, GATE_FEE, COST_PER_ADDITIONAL_TRUCK, FITNESS_WEIGHTS_SIMPLIFIED
                            );
                            
                            const currentBestFitnessInGen = Math.min(...fitnessScores);
                            
                            if (currentBestFitnessInGen < overallBestFitness) {
                                overallBestFitness = currentBestFitnessInGen;
                                const bestIdxInPop = fitnessScores.indexOf(currentBestFitnessInGen);
                                bestRouteOverall = newPopulation[bestIdxInPop];
                            }
                            
                            const parents = selectMatingPoolVrp(newPopulation, fitnessScores, numParentsMating);

                            const eliteIndividuals = [];
                            const sortedIndicesForElite = argsort(fitnessScores);
                            for (let i = 0; i < Math.min(numElite, solPerPop); i++) {
                                eliteIndividuals.push(newPopulation[sortedIndicesForElite[i]]);
                            }

                            let numOffspring = solPerPop - eliteIndividuals.length;
                            if (numOffspring < 0) numOffspring = 0;

                            let offspringCrossover = crossoverVrp(parents, [numOffspring], binIdsList, DEFAULT_DEPOT_ID, DEFAULT_INCINERATOR_ID);

                            if (offspringCrossover.length < numOffspring) {
                                const neededMore = numOffspring - offspringCrossover.length;
                                for (let _ = 0; _ < neededMore; _++) {
                                    if (parents.length > 0) {
                                        offspringCrossover.push([...randomSample(parents, 1)[0]]);
                                    } else {
                                        offspringCrossover.push(createInitialVrpPopulation(1, binIdsList, numTrucksForGa, DEFAULT_DEPOT_ID, DEFAULT_INCINERATOR_ID, DEFAULT_TRUCK_CAPACITY, currentBinsData)[0]);
                                    }
                                }
                            }

                            const offspringMutation = mutationVrp(offspringCrossover, mutationRate, binIdsList, DEFAULT_DEPOT_ID, DEFAULT_INCINERATOR_ID);
                            
                            newPopulation = [];
                            newPopulation.push(...eliteIndividuals);
                            newPopulation.push(...offspringMutation);

                            if (newPopulation.length > solPerPop) {
                                newPopulation = newPopulation.slice(0, solPerPop);
                            } else if (newPopulation.length < solPerPop) {
                                const neededToFill = solPerPop - newPopulation.length;
                                const newIndividuals = createInitialVrpPopulation(neededToFill, binIdsList, numTrucksForGa, DEFAULT_DEPOT_ID, DEFAULT_INCINERATOR_ID, DEFAULT_TRUCK_CAPACITY, currentBinsData);
                                newPopulation.push(...newIndividuals);
                            }
                        }

                        // --- Final Results Calculation for Display ---
                        const finalBestFitnessDetails = calculateFitnessVrpSimplified(
                            bestRouteOverall, currentBinsData, DEFAULT_TRUCK_CAPACITY,
                            incineratorLocation, depotLocation,
                            DEFAULT_END_DEPOT_LOCATION, DEFAULT_TRUCK_SPEED,
                            DEFAULT_INCINERATOR_UNLOAD_TIME, COST_PER_KM, GATE_FEE, COST_PER_ADDITIONAL_TRUCK, FITNESS_WEIGHTS_SIMPLIFIED
                        );
                        
                        let calculatedTotalDistance = 0;
                        let calculatedIncineratorTrips = 0;
                        let calculatedTrucksUsed = 0;

                        for (const truckRoute of bestRouteOverall) {
                            let currentTruckDistanceTemp = 0;
                            let currentLoadTemp = 0;
                            let lastLocationTemp = depotLocation;
                            let hasCollectedAnyBinsThisTruckTemp = false;

                            const hasAnyBinsInRouteTemp = truckRoute.some(stopId => currentBinsData.hasOwnProperty(stopId));
                            if (hasAnyBinsInRouteTemp) {
                                calculatedTrucksUsed = 1; // Fixed to 1 for this context
                            }

                            const processedRouteTemp = [...truckRoute];
                            if (!processedRouteTemp || processedRouteTemp[0] !== DEFAULT_DEPOT_ID) {
                                processedRouteTemp.unshift(DEFAULT_DEPOT_ID);
                            }

                            for (let i = 0; i < processedRouteTemp.length; i++) {
                                const stopId = processedRouteTemp[i];
                                let currentLocationTemp;

                                if (stopId === DEFAULT_DEPOT_ID) {
                                    currentLocationTemp = (i === 0) ? depotLocation : DEFAULT_END_DEPOT_LOCATION;
                                } else if (stopId === DEFAULT_INCINERATOR_ID) {
                                    currentLocationTemp = incineratorLocation;
                                    calculatedIncineratorTrips += 1;
                                    currentLoadTemp = 0;
                                } else {
                                    currentLocationTemp = currentBinsData[stopId]?.loc;
                                    currentLoadTemp += currentBinsData[stopId]?.volume;
                                    hasCollectedAnyBinsThisTruckTemp = true;
                                }

                                if (currentLocationTemp) {
                                    const dist = calculateDistance(lastLocationTemp, currentLocationTemp);
                                    currentTruckDistanceTemp += dist;
                                    lastLocationTemp = currentLocationTemp;
                                }
                            }
                            
                            if (hasCollectedAnyBinsThisTruckTemp && currentLoadTemp > 0) {
                                const distToIncTemp = calculateDistance(lastLocationTemp, incineratorLocation);
                                currentTruckDistanceTemp += distToIncTemp;
                                calculatedIncineratorTrips += 1;
                                const distIncToDepotTemp = calculateDistance(incineratorLocation, DEFAULT_END_DEPOT_LOCATION);
                                currentTruckDistanceTemp += distIncToDepotTemp;
                            } else {
                                if (lastLocationTemp !== DEFAULT_END_DEPOT_LOCATION) {
                                    const distToFinalDepotTemp = calculateDistance(lastLocationTemp, DEFAULT_END_DEPOT_LOCATION);
                                    currentTruckDistanceTemp += distToFinalDepotTemp;
                                }
                            }
                            calculatedTotalDistance += currentTruckDistanceTemp;
                        }

                        // Calculate penalties for the best route to display
                        let capacityPenaltyCheck = 0;
                        let unvisitedPenaltyCheck = 0;
                        let invalidBinPenaltyCheck = 0;
                        
                        const visitedBinsInBestSol = new Set();
                        for (const truckRoute of bestRouteOverall) {
                            let currentLoadForPenaltyCheck = 0;
                            for (const stopId of truckRoute) {
                                if (stopId === DEFAULT_INCINERATOR_ID) {
                                    currentLoadForPenaltyCheck = 0;
                                } else if (stopId === DEFAULT_DEPOT_ID) {
                                    // Do nothing
                                } else if (currentBinsData.hasOwnProperty(stopId)) {
                                    const binInfo = currentBinsData[stopId];
                                    if (currentLoadForPenaltyCheck + binInfo.volume > DEFAULT_TRUCK_CAPACITY) {
                                        capacityPenaltyCheck += (currentLoadForPenaltyCheck + binInfo.volume - DEFAULT_TRUCK_CAPACITY) * (FITNESS_WEIGHTS_SIMPLIFIED['capacity_violation'] || 50000);
                                    }
                                    currentLoadForPenaltyCheck += binInfo.volume;
                                    visitedBinsInBestSol.add(stopId);
                                } else {
                                    invalidBinPenaltyCheck += (FITNESS_WEIGHTS_SIMPLIFIED['invalid_bin'] || 200000);
                                }
                            }
                        }
                        
                        const unvisitedBinsCheck = new Set([...allBinsInProblem].filter(x => !visitedBinsInBestSol.has(x)));
                        unvisitedPenaltyCheck = unvisitedBinsCheck.size * (FITNESS_WEIGHTS_SIMPLIFIED['unvisited'] || 1000000);


                        setRouteResult({
                            route: bestRouteOverall[0], // Assuming single truck, take the first route
                            totalDistance: calculatedTotalDistance,
                            totalIncineratorTrips: calculatedIncineratorTrips,
                            totalCost: finalBestFitnessDetails,
                            trucksUsed: calculatedTrucksUsed,
                            capacityPenalty: capacityPenaltyCheck,
                            unvisitedPenalty: unvisitedPenaltyCheck,
                            invalidBinPenalty: invalidBinPenaltyCheck
                        });

                    } catch (err) {
                        console.error("Error running GA:", err);
                        setError(`Error running GA: ${err.message}. Check console for details.`);
                    } finally {
                        setIsLoading(false);
                    }
                }, 10); // Small delay to allow loading state to render
            };

            return (
                <div className="flex flex-col items-center justify-center min-h-screen bg-gray-100 p-4 font-inter">
                    <div className="bg-white p-8 rounded-lg shadow-lg w-full max-w-4xl">
                        <h1 className="text-3xl font-bold text-center text-gray-800 mb-6">VRP Optimization Frontend</h1>

                        <div className="flex justify-center space-x-4 mb-6">
                            <button
                                onClick={generatePoints}
                                className="px-6 py-3 bg-blue-600 text-white rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition duration-200 ease-in-out"
                                disabled={isLoading}
                            >
                                Generate New Points
                            </button>
                            <button
                                onClick={handleRunGaOptimization}
                                className="px-6 py-3 bg-green-600 text-white rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75 transition duration-200 ease-in-out"
                                disabled={isLoading}
                            >
                                {isLoading ? 'Running GA...' : 'Run GA Optimization'}
                            </button>
                        </div>

                        {isLoading && (
                            <div className="text-center text-blue-500 mb-4">
                                <p>Running Genetic Algorithm... This might take a moment.</p>
                                <p>Generations: {GA_NUM_GENERATIONS}, Population: {GA_SOL_PER_POP}</p>
                            </div>
                        )}

                        {error && (
                            <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4" role="alert">
                                <strong className="font-bold">Error:</strong>
                                <span className="block sm:inline"> {error}</span>
                            </div>
                        )}

                        <div className="border border-gray-300 rounded-lg overflow-hidden mb-6">
                            <canvas ref={canvasRef} width="800" height="600" className="bg-white"></canvas>
                        </div>

                        {routeResult && (
                            <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
                                <h2 className="text-xl font-semibold text-gray-700 mb-3">GA Optimized Route Details:</h2>
                                <p className="text-gray-600 mb-1">
                                    <strong>Total Distance:</strong> {routeResult.totalDistance.toFixed(2)} km
                                </p>
                                <p className="text-gray-600 mb-1">
                                    <strong>Total Incinerator Trips:</strong> {routeResult.totalIncineratorTrips}
                                </p>
                                <p className="text-gray-600 mb-1">
                                    <strong>Number of Trucks Used:</strong> {routeResult.trucksUsed}
                                </p>
                                <p className="text-gray-600 mb-1">
                                    <strong>Final Total Cost:</strong> S${routeResult.totalCost.toFixed(2)}
                                </p>
                                <div className="mt-2 text-sm text-gray-500">
                                    <strong>Penalties (should be 0 for valid solution):</strong>
                                    <ul className="list-disc list-inside ml-4">
                                        <li>Capacity Violation: S${routeResult.capacityPenalty.toFixed(2)}</li>
                                        <li>Unvisited Bin: S${routeResult.unvisitedPenalty.toFixed(2)}</li>
                                        <li>Invalid Bin: S${routeResult.invalidBinPenalty.toFixed(2)}</li>
                                    </ul>
                                </div>
                                <div className="mt-4 text-sm text-gray-500">
                                    <strong>Route Sequence (Truck 1):</strong> {routeResult.route.join(' -> ')}
                                </div>
                            </div>
                        )}

                        <div className="mt-6 text-center text-gray-500 text-sm">
                            <p>Depot: ({depotLocation.x}, {depotLocation.y})</p>
                            <p>Incinerator: ({incineratorLocation.x}, {incineratorLocation.y})</p>
                            <p>Total Trash Volume: {totalTrash.toFixed(2)} kg</p>
                            <p>Truck Capacity: {DEFAULT_TRUCK_CAPACITY} kg</p>
                        </div>
                    </div>
                </div>
            );
        };

        // Render the App component
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
