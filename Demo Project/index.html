<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VRP Genetic Algorithm Simulation</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f4; }
        .container { max-width: 1200px; margin: auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2 { color: #333; }
        button {
            padding: 10px 15px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        #controls { margin-bottom: 20px; }
        #graph { border: 1px solid #ddd; border-radius: 5px; margin-top: 20px; }
        #info { margin-top: 20px; padding: 10px; background-color: #e9ecef; border-radius: 5px; }
        .flex-container { display: flex; justify-content: space-between; align-items: flex-start; }
        .left-panel { flex: 1; margin-right: 20px; }
        .right-panel { flex: 1; }
    </style>
</head>
<body>
    <div class="container">
        <h1>VRP Genetic Algorithm Simulation</h1>

        <div id="controls">
            <button id="generateBinsBtn">Generate New Bin Locations</button>
            <button id="runGaBtn" disabled>Run Genetic Algorithm</button>
            <button id="prevGenBtn" disabled>Previous Generation</button>
            <button id="nextGenBtn" disabled>Next Generation</button>
        </div>

        <div id="info">
            <p><strong>Status:</strong> <span id="status">Ready</span></p>
            <p><strong>Current Generation:</strong> <span id="currentGen">N/A</span></p>
            <p><strong>Theoretical Min Cost:</strong> S$<span id="theoreticalMinCost">N/A</span></p>
            <p><strong>Current Route Fitness:</strong> S$<span id="currentFitness">N/A</span></p>
            <p><strong>Accuracy:</strong> <span id="accuracy">N/A</span>%</p>
            <p><strong>Distance:</strong> <span id="distance">N/A</span> km</p>
            <p><strong>Incinerator Trips:</strong> <span id="incineratorTrips">N/A</span></p>
            <p><strong>Trucks Used:</strong> <span id="trucksUsed">N/A</span></p>
        </div>

        <div id="graph" style="width:100%; height:600px;"></div>
    </div>

    <script>
        const API_BASE_URL = 'http://127.0.0.1:5000'; // Your Flask backend URL

        let currentBinsData = null;
        let theoreticalMinCost = null;
        let availableGenerations = [];
        let currentGenerationIndex = -1;
        let currentRouteData = null; // Store the currently displayed route's full data

        const generateBinsBtn = document.getElementById('generateBinsBtn');
        const runGaBtn = document.getElementById('runGaBtn');
        const prevGenBtn = document.getElementById('prevGenBtn');
        const nextGenBtn = document.getElementById('nextGenBtn');
        const statusSpan = document.getElementById('status');
        const currentGenSpan = document.getElementById('currentGen');
        const theoreticalMinCostSpan = document.getElementById('theoreticalMinCost');
        const currentFitnessSpan = document.getElementById('currentFitness');
        const accuracySpan = document.getElementById('accuracy');
        const distanceSpan = document.getElementById('distance');
        const incineratorTripsSpan = document.getElementById('incineratorTrips');
        const trucksUsedSpan = document.getElementById('trucksUsed');
        const graphDiv = document.getElementById('graph');

        // Function to plot the route
        function plotRoute(binsData, depotLoc, incineratorLoc, routeData) {
            const data = [];

            // Plot Depot
            data.push({
                x: [depotLoc[0]],
                y: [depotLoc[1]],
                mode: 'markers',
                type: 'scatter',
                name: 'Depot',
                marker: { symbol: 'square', size: 12, color: 'black' },
                hoverinfo: 'text',
                text: `Depot: (${depotLoc[0].toFixed(2)}, ${depotLoc[1].toFixed(2)})`
            });

            // Plot Incinerator
            data.push({
                x: [incineratorLoc[0]],
                y: [incineratorLoc[1]],
                mode: 'markers',
                type: 'scatter',
                name: 'Incinerator',
                marker: { symbol: 'triangle-up', size: 12, color: 'purple' },
                hoverinfo: 'text',
                text: `Incinerator: (${incineratorLoc[0].toFixed(2)}, ${incineratorLoc[1].toFixed(2)})`
            });

            // Plot Bins
            const bin_x = [];
            const bin_y = [];
            const bin_text = [];
            for (const binId in binsData) {
                bin_x.push(binsData[binId].loc[0]);
                bin_y.push(binsData[binId].loc[1]);
                bin_text.push(`Bin ${binId}: Vol ${binsData[binId].volume.toFixed(0)}kg`);
            }
            data.push({
                x: bin_x,
                y: bin_y,
                mode: 'markers',
                type: 'scatter',
                name: 'Bins',
                marker: { symbol: 'circle', size: 8, color: 'blue' },
                hoverinfo: 'text',
                text: bin_text
            });

            // Plot Routes
            const colors = ['red', 'green', 'cyan', 'orange', 'darkblue', 'brown', 'pink', 'lime'];
            routeData.forEach((truckRoute, truckIndex) => {
                const route_x = [];
                const route_y = [];
                const route_text = [];
                let prevCoords = null;

                truckRoute.forEach(stop => {
                    route_x.push(stop.coords[0]);
                    route_y.push(stop.coords[1]);
                    route_text.push(stop.id);

                    // Add arrows for direction
                    if (prevCoords) {
                        data.push({
                            x: [prevCoords[0], stop.coords[0]],
                            y: [prevCoords[1], stop.coords[1]],
                            mode: 'lines',
                            type: 'scatter',
                            line: { color: colors[truckIndex % colors.length], width: 2 },
                            showlegend: false,
                            hoverinfo: 'skip'
                        });
                        // Plotly does not have native arrowheads. We can draw an additional marker or use annotations
                        // For simplicity, we just draw lines here. Advanced users can use annotations for arrows.
                    }
                    prevCoords = stop.coords;
                });

                data.push({
                    x: route_x,
                    y: route_y,
                    mode: 'lines+markers',
                    type: 'scatter',
                    name: `Truck ${truckIndex + 1}`,
                    line: { color: colors[truckIndex % colors.length], width: 2 },
                    marker: { symbol: 'circle', size: 6, color: colors[truckIndex % colors.length] },
                    hoverinfo: 'text',
                    text: route_text
                });
            });

            const layout = {
                title: `VRP Solution for Generation ${availableGenerations[currentGenerationIndex]}`,
                xaxis: { title: 'X-coordinate (km)' },
                yaxis: { title: 'Y-coordinate (km)', scaleanchor: "x", scaleratio: 1 },
                hovermode: 'closest',
                showlegend: true,
                legend: { x: 1.05, y: 1, xanchor: 'left', yanchor: 'top' }
            };

            Plotly.newPlot(graphDiv, data, layout);
        }

        // Event Listeners
        generateBinsBtn.addEventListener('click', async () => {
            statusSpan.textContent = 'Generating new bins...';
            runGaBtn.disabled = true;
            prevGenBtn.disabled = true;
            nextGenBtn.disabled = true;
            try {
                const response = await fetch(`${API_BASE_URL}/generate_bins`);
                const result = await response.json();
                currentBinsData = result.bins_data;
                const depotLoc = result.depot_location;
                const incineratorLoc = result.incinerator_location;
                theoreticalMinCost = null; // Reset theoretical min cost
                currentGenerationIndex = -1; // Reset generation viewer

                // Clear previous plot and info
                Plotly.newPlot(graphDiv, [], {}); // Clear plot
                updateInfo(null); // Clear info

                // Plot just bins, depot, and incinerator
                const initialData = [];
                initialData.push({
                    x: [depotLoc[0]], y: [depotLoc[1]], mode: 'markers', type: 'scatter', name: 'Depot', marker: { symbol: 'square', size: 12, color: 'black' }
                });
                initialData.push({
                    x: [incineratorLoc[0]], y: [incineratorLoc[1]], mode: 'markers', type: 'scatter', name: 'Incinerator', marker: { symbol: 'triangle-up', size: 12, color: 'purple' }
                });
                const bin_x = []; const bin_y = [];
                for (const binId in currentBinsData) {
                    bin_x.push(currentBinsData[binId].loc[0]);
                    bin_y.push(currentBinsData[binId].loc[1]);
                }
                initialData.push({
                    x: bin_x, y: bin_y, mode: 'markers', type: 'scatter', name: 'Bins', marker: { symbol: 'circle', size: 8, color: 'blue' }
                });
                Plotly.newPlot(graphDiv, initialData, {
                    title: 'Generated Bin Locations',
                    xaxis: { title: 'X-coordinate (km)' },
                    yaxis: { title: 'Y-coordinate (km)', scaleanchor: "x", scaleratio: 1 },
                    showlegend: true,
                    legend: { x: 1.05, y: 1, xanchor: 'left', yanchor: 'top' }
                });


                statusSpan.textContent = 'Bins generated. Ready to run GA.';
                runGaBtn.disabled = false;
            } catch (error) {
                console.error('Error generating bins:', error);
                statusSpan.textContent = `Error: ${error.message}`;
            }
        });

        runGaBtn.addEventListener('click', async () => {
            if (!currentBinsData) {
                alert('Please generate bin locations first!');
                return;
            }
            statusSpan.textContent = 'Running Genetic Algorithm... This may take a while.';
            runGaBtn.disabled = true;
            generateBinsBtn.disabled = true;
            prevGenBtn.disabled = true;
            nextGenBtn.disabled = true;
            try {
                const response = await fetch(`${API_BASE_URL}/run_ga`, { method: 'POST' });
                const result = await response.json();
                console.log(result);

                theoreticalMinCost = result.theoretical_minimum_cost_benchmark;
                theoreticalMinCostSpan.textContent = theoreticalMinCost.toFixed(2);

                availableGenerations = Object.keys(result.results_by_generation).map(Number).sort((a, b) => a - b);
                currentGenerationIndex = -1; // Reset to -1 so 'next' button can show first result

                statusSpan.textContent = 'GA completed. Click "Next Generation" to view results.';
                generateBinsBtn.disabled = false;
                nextGenBtn.disabled = availableGenerations.length === 0;
                prevGenBtn.disabled = true; // Initially disabled
                
                // Automatically display the first generation if available
                if (availableGenerations.length > 0) {
                    currentGenerationIndex = 0;
                    displayGeneration(availableGenerations[currentGenerationIndex]);
                }

            } catch (error) {
                console.error('Error running GA:', error);
                statusSpan.textContent = `Error: ${error.message}`;
                runGaBtn.disabled = false;
                generateBinsBtn.disabled = false;
            }
        });

        nextGenBtn.addEventListener('click', () => {
            if (currentGenerationIndex < availableGenerations.length - 1) {
                currentGenerationIndex++;
                displayGeneration(availableGenerations[currentGenerationIndex]);
            }
        });

        prevGenBtn.addEventListener('click', () => {
            if (currentGenerationIndex > 0) {
                currentGenerationIndex--;
                displayGeneration(availableGenerations[currentGenerationIndex]);
            }
        });

        async function displayGeneration(gen) {
            statusSpan.textContent = `Fetching data for generation ${gen}...`;
            try {
                const response = await fetch(`${API_BASE_URL}/get_route_data/${gen}`);
                currentRouteData = await response.json(); // Store the full data

                if (currentBinsData) { // Ensure bins data is available for plotting
                    plotRoute(
                        currentBinsData,
                        [0, 0], // Depot location
                        [30, 30], // Incinerator location
                        currentRouteData.best_route // The route data itself
                    );
                    updateInfo(currentRouteData);
                } else {
                    console.error("Bins data not available for plotting.");
                    statusSpan.textContent = "Error: Bins data not available.";
                }

                // Update button states
                prevGenBtn.disabled = currentGenerationIndex === 0;
                nextGenBtn.disabled = currentGenerationIndex === availableGenerations.length - 1;
                statusSpan.textContent = `Displaying generation ${gen}.`;

            } catch (error) {
                console.error('Error fetching route data:', error);
                statusSpan.textContent = `Error displaying generation ${gen}: ${error.message}`;
            }
        }

        function updateInfo(data) {
            if (data) {
                currentGenSpan.textContent = availableGenerations[currentGenerationIndex];
                currentFitnessSpan.textContent = data.fitness.toFixed(2);
                accuracySpan.textContent = data.accuracy.toFixed(2);
                distanceSpan.textContent = data.total_distance.toFixed(2);
                incineratorTripsSpan.textContent = data.incinerator_trips;
                trucksUsedSpan.textContent = data.trucks_used;
            } else {
                currentGenSpan.textContent = 'N/A';
                currentFitnessSpan.textContent = 'N/A';
                accuracySpan.textContent = 'N/A';
                distanceSpan.textContent = 'N/A';
                incineratorTripsSpan.textContent = 'N/A';
                trucksUsedSpan.textContent = 'N/A';
            }
            theoreticalMinCostSpan.textContent = theoreticalMinCost !== null ? theoreticalMinCost.toFixed(2) : 'N/A';
        }

        // Initial state
        generateBinsBtn.click(); // Automatically generate bins on page load
    </script>
</body>
</html>